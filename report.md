# 《计算机图形学》4月报告

## 综述

+ 完成内容：
+ 开发环境：Ubuntu 18.04 Python 3.7.0

## 算法介绍

### 直线绘制

按照实验要求实现了DDA与Bresenham直线绘制算法。

#### DDA算法

+ 原理
  + 使用$x$或$y$方向单位增量间隔，逐步计算沿线路径上各像素点的位置
  + 在增量绝对值更大的方向上按照单位增量对线段离散取样，利用增量的比例计算出取样点在另一个方向上的坐标（此处需要取整操作）
+ 实现
  + 对于输入起始点(x0,y0), (x1,y1)，先计算出各自的增量dx, dy
  + 选取增量中绝对值较大的一者为`step=max(abs(dx), abs(dy))`
  + $x,y$方向每次的增量分别为`dx/step, dy/step`
  + 两个方向上每次递增增量并取整(`round()`)，计算出`step+1`个点组成直线
+ 分析
  + 优点：符合数学直观，易于理解和记忆；消除了直线方程 中的乘法
  + 缺点：每个点的像素位置都需要面临取整，可能会产生累积误差（长线段所计算的像素位置可能会偏离实际线段）；涉及大量浮点运算和取整操作，比较耗时

#### Bresenham算法

+ 原理

  + 利用直线点的连续性，从起点开始，（斜率$0<m<1$的直线）每次选取的下一个点要么是当前点右侧相邻的点，要么是当前点右上角相邻的点
+ 分别计算两个候选点与直线方程计算得到的实际点的偏移$d_1$（右侧点的偏移）和$d_2$（右上角点的偏移），总是选择离实际点较近的那个点
  
  + 对于偏移量不进行真正的浮点计算，而是使用作差法并将计算公式变形并化简为仅包含整数运算的\textup{决策参数}$p_k=\Delta x(d_1-d_2)=2\Delta yx_k-2\Delta xy_k+c$($c$为常数)。根据第$k$步决策参数的符号，判定两候选像素与线段的偏移关系。
+ 从第$k$步到第$k+1$步只需要计算决策参数的增量就可以更新决策参数
  $$
  p_{k+1}=p_{k}+2\Delta y-2\Delta x(y_{k+1}-y_k)=
            \begin{cases}
            p_k+2\Delta y-2\Delta x &p_k>0\;(y_{k+1}=y_k+1)\\
            p_k+2\Delta y & p_k<0\;(y_{k+1}=y_k)
            \end{cases}
  $$
  + 决策参数初始值为$p=2\Delta y-\Delta x$。

+ 实现

  + 输入直线的起始点`(x0,y0), (x1,y1)`，如果发现是水平或垂直线（`x0 == x1 or y0 == y1`）直接输出所有端点。
  + 计算常量：`dx, dy`，由于实现基于Python而非硬件环境，且对效率的要求并不苛刻，每次计算$2\Delta y$和$2\Delta y-2\Delta x$的时间可以忽略不计，故此处不作存储。
  + 判断直线生成方向是否与坐标轴方向一致（`(m > 0 and x0 < x1) or (m < 0 and y0 < y1)`），不一致时交换起始点坐标
  + 按照斜率绝对值和1的关系（`dx, dy`的相对大小）分情况处理。按照原理部分所述的步骤计算每步的决策参数，决定当前加入集合的点

+ 实现时遇到的困难及解决

  + 按照ppt给出算法实现的时候，ppt上只给出了斜率$m>1$时的做法，我也只按照斜率的绝对值与1的大小关系区分了实现。测试时才发现$m<-1$时决策参数的公式是不一样的。正确的做法应该是1)$\Delta x$和$\Delta y$需要取绝对值，2)$p_k>$时应有$y_{k+1}=y_k-1$，因为候选点是当前点右侧或右下角的相邻点。

+ 分析

  + 优点：全都是整数计算，硬件实现非常容易，也不会出现累计误差
  + （不算缺点的）缺点：计算有些琐碎，有8种不一样的直线情况需要分类讨论（有些情况可以合并），需要一定时间理解和消化

  

### 椭圆绘制

按照要求，实现的是Bresenham中点椭圆生成算法

+ 原理

  + 利用**平移**和**对称性**，只需要生成第一象限部分的曲线。而第一象限被斜率为-1的切线的切点分为了两部分。前半部分$\Delta x$较大，以$x$轴为基准计算；后半部分$\Delta y$较大，反之。下讨论前半部分的绘制思路。

  + 与Bresenham直线绘制算法类似，根据椭圆线段的连续性，下一个像素必然是当前点$(x_k, y_k)$的右侧像素$(x_k+1,y_k)$或右下侧像素$(x_k+1, y_k-1)$。考察这两个候选像素的中点$(x_k+1, y_k-1/2)$与椭圆$f(x,y)$的位置关系可以得知哪个点与实际曲线上的点离得更近。

  + |                       | 中点           | 像素选择                             |
    | --------------------- | -------------- | ------------------------------------ |
    | $f(x_k+1, y_k-1/2)<0$ | 中点位于椭圆内 | 右侧像素与实际点更近                 |
    | $f(x_k+1, y_k-1/2)=0$ | 中点位于椭圆上 | 右侧像素和右下侧像素与实际点距离相同 |
    | f(x_k+1, y_k-1/2)>0$  | 中点位于椭圆外 | 右下侧像素与实际点更近               |

  + 经过化简，可以将
$$
    p1_k=f(x_k+1,y_k-1/2)=r_y^2(x_k+1)^2+r_x^2(y_k-1/2)-r_xr)y^2
$$
    作为决策参数，根据其符号来决定下一个像素的选择。初值为$p1_0=r_y^2-r_x^2*r_y+r_x^2/4$。

  + 同Bresenham直线绘制算法，可以使用增量来更新决策参数，即
    $$
    p1_{k+1}=\begin{cases}
          p1_k+2r_y^2x_{k+1}+r_y^2 & p1_k < 0\\
          p1_k+2r_y^2x_{k+1}-2r_x^2y_{k+1}+r_y^2 & p1_k>0\end{cases}
    $$

  + 第一部分计算到$2r_y^2x\ge 2r_x^2y$为止（斜率为-1的切线与椭圆的交点）。计算椭圆第二部分的原理类似。

  + 第二部分更换$y$轴为递增单位。决策参数初值为$p2_0=r_y^2(x_1+1/2)^2+r_x^2(y_1-1)^2-r_x^2r_y^2$。候选像素点为下方$(x_k, y_k-1)$和右下方$(x_k+1,y_k-1)$的像素。增量更新公式为

$$
  p2_{k+1}=\begin{cases}
        p2_k-2r_x^2y_{k+1}+r_x^2 & p2_k>0\\
        p2_k+2r_y^2x_{k+1}-2r_x^2y_{k+1}+r_x^2 & p2_k<0
      \end{cases}
$$

+ 实现

  + 输入椭圆的外接矩形的左上角和右下角坐标`(x0,y0), (x1,y1)`，计算出椭圆的长轴、短轴和圆心位置。

    计算出几个常用数值`rx2=rx*rx, ry2=ry*ry`
  + 按照上述原理，递增计算每一步的决策参数选择像素点，分为两部分绘制椭圆的第一象限中的曲线。
  + 将第一象限中的部分对称到其他三个象限中，并整体平移到圆心指示的位置上。

+ 实现时遇到的困难及解决

  + 起初按照ppt上给出的过程实现的，会出现“烈焰红唇”一样的形状，一步一步推导后才发现ppt中第二部分的初始值公式中少打了一个平方符号。深刻体会到了自己理解算法的重要性，不然就被坑了呀。

+ 分析

  + 优缺点基本同Bresenham直线绘制算法

### 多边形绘制

直接使用了框架提供的代码：在输入点两两之间绘制直线相连

### 曲线绘制

#### Brezier曲线

#### 三次B样条曲线

### 平移变换

+ 原理
  + 将待平移图形的每个坐标加上需要平移的量
+ 实现
  + 实际实现中，只需平移每种图形的“定位点”（直线的端点、多边形的所有顶点、椭圆的外接矩形顶点、曲线的定位点等），返回平移后的点并调用绘制算法重新绘制这些曲线即可

### 旋转变换

+ 原理

  + 先考虑旋转中心为坐标原点的情况：利用极坐标表示可以得到平移变换后点的计算公式
  $$
  \begin{cases}
        x_1=x\cos\theta-y\sin\theta\\
        y_1=x\sin\theta+y\cos\theta
      \end{cases}
  $$
  + 即变换矩阵为
    $$
    R=\begin{bmatrix}
          \cos\theta & -\sin\theta\\
          \sin\theta & \cos\theta
          \end{bmatrix}
    $$
    
  + 当旋转中心非坐标原点时，可以暂时以旋转中心$(x_r,y_r)$为原点建立临时坐标系，再讲旋转后的图形坐标变换回到原坐标系中即可，即
$$
\begin{cases}
      x_1=x_r+(x-x_r)\cos\theta-(y-y_r)\sin\theta\\
      y_1=y_r+(x-x_r)\sin\theta+(y-y_r)\cos\theta
    \end{cases}
$$

### 缩放变换

### 线段裁剪

#### Cohen-Sutherland算法

+ 原理

  + 核心思想：通过编码测试来减少要计算交点的次数

  + 线段端点按区域赋以四位二进制码（区域码），用来标识线段端点与四条裁剪窗口边界的相对位置关系，从右到左依次表示左右下上边界，为1表示端点落在相应边界上

    | 1001 |     1000     | 1010 |
    | ---- | :----------: | ---- |
    | 0001 | 0000（窗口） | 0010 |
    | 0101 |     0100     | 0110 |

  + 根据线段端点的区域码快速判断线段与窗口的位置关系

    + 完全在窗口边界内的线段：两端点区域码均为0000
    + 完全在窗口边界外的线段：两端点区域码同样位置都为1（与操作后结果不为0000）

  + 对于不能确定线段是否全部在窗口内或外的线段进行求交运算的迭代

    + 按左-右-下-上的顺序检查线段端点的区域码，线段端点与每个裁剪边界比较和求交，剩下部分与下一个边界比较和求交，直到该线段完全被舍弃或完全位于窗口内为止

+ 实现

  + 编写了一个函数`oc=outcode(x, y, x_min, y_min, x_max, y_max)`用于计算点`(x,y)`的区域码
  + 迭代计算一个端点的区域码，并与每个边界的区域码相比较，如果与该边界相交就计算出交点并将交点作为新的端点。若该端点已经落在区域内，就对另一个端点执行相同操作。直到线段的两个端点都在区域内或都在区域外为止。
  + 如果最终两个端点都位于区域内（边界上），就返回此时线段的端点

  ```python
  oc0 = outcode(x0, y0, x_min, y_min, x_max, y_max)
  oc1 = outcode(x1, y1, x_min, y_min, x_max, y_max)
  accept = False
  while True:
      if oc0 == 0 and oc1 == 0:
          # 两端点都在区域内
          accept = True
          break
          elif (oc0 & oc1) != 0:
              # 两端点都在区域外
              break
              else:
                  # 处理在区域外的点
                  oc = oc0
                  if oc0 == 0:
                      oc = oc1
                      left, right, down, up = 0b0001, 0b0010, 0b0100, 0b1000
                      dx, dy = x1 - x0, y1 - y0
                      # 寻找线段与每个边界的交点并更新端点
                      if oc & left:
                          x, y = x_min, (x_min - x0) * dy / dx + y0
                          elif oc & right:
                              x, y = x_max, (x_max - x0) * dy / dx + y0
                              elif oc & up:
                                  x, y = (y_min - y0) * dx / dy + x0, y_min
                                  elif oc & down:
                                      x, y = (y_max - y0) * dx / dy + x0, y_max
                                      if oc == oc0:
                                          x0, y0, oc0 = x, y, outcode(x, y, x_min, y_min, x_max, y_max)
                                          else:
                                              x1, y1, oc1 = x, y, outcode(x, y, x_min, y_min, x_max, y_max)
  ```

  

#### Liang-Barsky算法

+ 原理

  + **核心思想**：将二维平面中的直线与裁剪框降维到一维空间中，一维空间内（即数轴上的）裁剪算法是非常简单直接的

  + 直线的参数方程可以写成（$t$为参数）
    $$
    x(t)=x_0+t(x_1-x_0)\\
    y(t)=y_0+t(y_1-y_0)
    $$

  + 裁剪条件为
    $$
    x_{min}\le x(t)\le x_{max}\\
    y_{min}\le y(t)\le y_{max}
    $$

  + 带入参数方程可以得到：
    $$
    -t\Delta x<x_0-x_{min},\quad t\Delta x<x_{max}-x_0\\
    -t\Delta y<y_0-y_{min},\quad t\Delta y<y_{max}-y_0
    $$

  + 可以将形式统一为：（$i=1,2,3,4$时分别代表边框的左右上下侧）
    $$
    d_i<q_i, i=1,2,3,4\\
    d_1=-\Delta x,\quad d_2=\Delta x,\quad d_3=-\Delta y, d_4=\Delta y\\
    q_1=x_0-x_{min},\quad q_2=x_{max}-x_0,\quad q_3=y_0-y_{min},\quad q_4=y_{max}-y_0
    $$
    
  + $q_i$可以用来判断直线起点$P_0$与裁剪边框的位置关系，即当$q_i\ge 0$时$P_0$位于可见侧。$d_i$表示直线斜率与裁剪边框的关系，因此当$d_i=0$且$q_i<0$时直线与边框平行且整体处于不可见处，可以简单抛弃。
  
  + 当直线与边框存在交点时，交点处对应的参数值即$t_i=q_i/d_i$，只需要将左右交点处的参数值求出并代入参数方程中，就可以得到交点的实际坐标
  
+ 实现

  + 准备了一个函数`visible, tl, tu = clipt(d, q, tl, tu)`，用来判断是否存在可见线段，若存在（`visible`返回`True`） 则计算每一侧参数的范围`[t_L, t_U]`
  + 对$(d_i,q_i), i=1,2,3,4$依次调用`clipt()`函数得到最终的$[t_l,t_u]$范围，计算出裁剪后的直线端点坐标即可

+ 分析

  + 与Cohen-Sutherland算法相比计算量更小：更新参数范围总共只需做4次除法，裁剪后的直线段点坐标计算只包含加法与乘法

## 参考资料

+ [B样条曲线——de Boor递推算法实现](https://blog.csdn.net/Hachi_Lin/article/details/89812126)
+ [n 阶贝塞尔曲线计算公式实现](https://blog.csdn.net/aimeimeits/article/details/72809382)
+ [Cohen-Sutherland](https://en.wikipedia.org/wiki/Cohen%E2%80%93Sutherland_algorithm)